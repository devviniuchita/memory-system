<div align="center">

# ‚ö° MEMORY SYSTEM ‚ö°

version 2.0

## _O Primeiro Sistema de Engenharia de Contexto H√≠brido que transforma a Mem√≥ria Persistente da IA em um ciclo Neural Evolutivo_

**RAG - Knowledge Graphs - Vetorization**

[![GitHub Stars](https://img.shields.io/github/stars/devviniuchita/memory-system?style=for-the-badge&logo=github&color=gold&logoColor=white)](https://github.com/devviniuchita/memory-system/stargazers)
[![Licen√ßa MIT](https://img.shields.io/badge/Licen√ßa-MIT-blue.svg?style=for-the-badge)](https://opensource.org/licenses/MIT)
[![MCP Protocol](https://img.shields.io/badge/MCP-Compat√≠vel-green.svg?style=for-the-badge&logo=protocol&logoColor=white)](https://modelcontextprotocol.io)
[![Enterprise Ready](https://img.shields.io/badge/Enterprise-Ready-purple.svg?style=for-the-badge&logo=enterprise&logoColor=white)]()

### üöÄ **APLICA√á√ÉO INTELIGENTE DE 9 FASES OBRIGAT√ìRIAS** üöÄ

_Sincroniza√ß√£o de regras dual-brain_<br>
_Orquestra√ß√£o tripla de MCPs_<br>
_Inje√ß√£o de contexto cont√≠nuo_

**üìã Navega√ß√£o R√°pida:** [‚öôÔ∏è Instala√ß√£o](#instalacao) ‚Ä¢ [üî• Por que usar?](#por-que-usar) ‚Ä¢ [üéØ Como Usar](#como-usar) ‚Ä¢ [üß† Recursos](#recursos) ‚Ä¢ [üåü Demo](#demo) ‚Ä¢ [üöÄ Em A√ß√£o](#em-acao) ‚Ä¢ [üìù Changelog](./CHANGELOG.md)

</div>

---

<a id="por-que-usar"></a>

## üî• Por que usar o Memory System?

Modelos de linguagem ou LLMs (Large Language Models) possuem um **n√∫mero m√°ximo de tokens** que conseguem "lembrar" por vez (ex: 8k, 32k, 128k tokens).
Intera√ß√µes longas ou contextos muito extensos podem inevitavelmente "ultrapassar esse limite", e na pr√°tica ocorre que as mensagens mais antigas s√£o "cortadas ou substitu√≠das". Isso cria um efeito de "decad√™ncia de contexto", ou simplesmente um **Decay**, onde as informa√ß√µes do in√≠cio da conversa simplesmente desaparecem abrindo margem para a t√£o temida **Alucina√ß√£o de IA**.

E como solucionar isso? √â a√≠ onde entra o **RAG (Retrieval Augmented Generation)**, que √© uma abordagem de IA que permite que os modelos de linguagem sejam capazes de recuperar informa√ß√µes relevantes de fontes ou documentos, aumentando assim os seus contextos. Ent√£o com isso chegamos a solu√ß√£o? E a resposta √© n√£o! Embora o contexto ajude LLMs de forma mais eficiente, o problema √© que eles n√£o s√£o capazes de **reter** informa√ß√µes de forma persistente, ficando assim, "ref√©ns da cola", o que significa que sem essa inje√ß√£o constante de "cola", eles **esquecem** rapidamente as informa√ß√µes mais antigas e continuam a **decair** seu contexto. E a grande evolu√ß√£o disso foi o que? Os t√£o revolucion√°rios e famosos **MCPs (Model Context Protocol)**, que s√£o **servidores de contexto que podem ser internos e externos** que permitem que os modelos de linguagem sejam capazes de recuperar informa√ß√µes relevantes de fontes de dados de forma mais din√¢mica, al√©m de gerar respostas com base nessas informa√ß√µes, interagir com diversos servi√ßos e com uma recupera√ß√£o de contexto muito mais r√°pida e eficiente.

A√≠ vem aquela pergunta novamente: √â a solu√ß√£o? E em **partes, √© sim!** E por que n√£o totalmente? Porque MCPs de mem√≥ria por exemplo, embora eficazes, sozinhos acabam n√£o sendo "bem aproveitados" pelas IAs, pois elas s√£o **muito espec√≠ficas** para o contexto em que foram treinadas, o que significa que **ainda n√£o s√£o capazes de generalizar** para outros contextos de forma din√¢mica e muito menos **s√£o capazes de filtrar** quais as qualidades dessas mem√≥rias que est√£o sendo armazenadas. √â a√≠ onde a grande solu√ß√£o, pode se tornar **UM GRANDE PROBLEMA!** Pois se a **IA registra mem√≥rias de m√°s qualidades**, ou porventura mem√≥rias geradas de **erros**, logo ela ir√° recuperar **MEM√ìRIAS RUINS** e se **BASEAR EM ERROS**.

Foi pensando nisso que desenvolvi o **Memory System**, que funciona como um **Multi Sistema H√≠brido** que mescla e integra diferentes formas de inje√ß√£o de contexto de forma sin√©rgica e cont√≠nua. Dentre as suas principais fun√ß√µes est√£o o sistema fallbacks, que mant√©m o sistema funcionando em caso de falhas, 3 MCPs funcionando em sinergia sob fortes, inflex√≠veis e seguras regras de Compliance, m√©tricas e requisitos exigentes para mem√≥rias gravadas ou n√£o e grande diferencial de todos, que √© fluxo de grava√ß√£o e recupera√ß√£o cont√≠nua baseado em duas etapas, sendo:

- Pr√©-tarefa: Recupera√ß√£o de contexto pr√©vio baseado em mem√≥rias persistentes
- P√≥s-tarefa: Armazenamento de aprendizados baseado em tarefas bem sucedidas.

Ou seja, basicamente o sistema garante que **boas mem√≥rias sejam armazenadas sob fortes condi√ß√µes de seguran√ßa, compliance e success_metrics** e que essas mesmas **boas mem√≥rias sejam reutilizadas** e **reaproveitadas**, o que torna na pr√°tica, um VERDADEIRO **SISTEMA NEURAL de auto-aprendizado cont√≠nuo das IAs.**

E tudo isso √© poss√≠vel gra√ßas ao sistema de **Engenharia de Contexto H√≠brida** que mesclam met√≥dos de **Reinforcement fine-tuning (RFT)**, **Chain of thought (CoT)** e **Reinforcement learning (RL)** que em sinergia e refor√ßo m√∫tuo, **injetam contexto na LLM** a cada **intera√ß√£o via Sync**.

E como isso tudo funciona? Aqui est√£o os arquivos principais que comp√µem o Memory System:

- **`memory-rules.mdc`**: define **COMO** executar as opera√ß√µes (orquestra recupera√ß√£o + armazenamento + pol√≠ticas)
- **`memory-rating.mdc`**: define **QUANDO** e com **QUAL QUALIDADE** ir√° executar as opera√ß√µes(classifica√ß√£o, reten√ß√£o, decay)

E para garantir que essas duas fun√ß√µes funcionem, foi criado um **SISTEMA AVAN√áADO DE SINCRONIZA√á√ÉO** com c√≥digo de alta qualidade em:

- **TypeScript + JavaScript**: _Dupla compatibilidade (dev + prod)_

Que garantem que ambos os **"c√©rebros"** _(execution e quality)_ operem em perfeita harmonia via `Async/Await`: Opera√ß√µes biderecionais - n√£o-bloqueantes e performance otimizada.

Esses arquivos s√£o:

- **`memory-dual-brain-sync.js`**: Executa o monitoramento
- **`memory-dual-brain-sync-oneshot.js`**: Faz a sincroniza√ß√£o
- **`memory-dual-brain-sync.ts`**: C√≥digo-fonte TypeScript
- **Scripts de execu√ß√£o multiplataforma**: `run-sync.bat` (Windows) e `run-sync.sh` (Unix/Linux)

**Toda essa sincroniza√ß√£o h√≠brida gera nosso revolucion√°rio:**

### _DUAL-BRAIN_

Que tem por sua principal fun√ß√£o - **ORQUESTRAR O SISTEMA TRI-MCP**<br>

> üéâ **NOVIDADE!** O sistema atualizou para a _version 2.0_ e est√° ainda melhor! Agora com sistema **RAG vetorizado** com Chunks, Reranking, FAISS e Langchain-Huggingface.
>
> üìñ Para mais informa√ß√µes acesse: **[CHANGELOG.md](CHANGELOG.md)**<br><br>

---

### üîÑ **DEMONSTRATIVO DE COMO O DUAL-BRAIN ORQUESTRA O FLUXO CONTINUO TRI-MCP**

<div align="center">

<img src="./images/flowchart.png" alt="Flowchart" width="450"/>

</div>

---

### üíî A Realidade Atual

<div align="center">

| Sem Memory System                          | Com Memory System                                 |
| ------------------------------------------ | ------------------------------------------------- |
| ‚ùå Esquece tudo entre sess√µes              | ‚úÖ Aprendizado cont√≠nuo entre conversa√ß√µes        |
| ‚ùå Repete os mesmos erros infinitamente    | ‚úÖ Aprende com erros e se adapta                  |
| ‚ùå Nenhum contexto sobre suas prefer√™ncias | ‚úÖ Personaliza com base em seus padr√µes           |
| ‚ùå Respostas gen√©ricas e padronizadas      | ‚úÖ Assist√™ncia contextual e consciente do projeto |
| ‚ùå N√£o aprende com erros passados          | ‚úÖ Loops de melhorias cont√≠nuas                   |

</div>

---

## üî• Memory System: A Solu√ß√£o

**Memory System** cria a primeira **camada de mem√≥ria persistente de IA** que realmente aprende e evolui:

<a id="recursos"></a>

### üß† **Arquitetura Dual-Brain**

<div align="center">

<img src="./images/dual.brain.png" alt="Configura√ß√£o Dual Brain" width="450"/>

</div>

#### üîß **Componentes do Sistema de Sincroniza√ß√£o**

<div align="center">

| Componente                              | Fun√ß√£o                                 | Uso Recomendado                  |
| --------------------------------------- | -------------------------------------- | -------------------------------- |
| **`memory-dual-brain-sync.js`**         | Sistema completo com watch de arquivos | Desenvolvimento cont√≠nuo         |
| **`memory-dual-brain-sync-oneshot.js`** | Execu√ß√£o √∫nica, sem loops infinitos    | Produ√ß√£o e automa√ß√£o             |
| **`memory-dual-brain-sync.ts`**         | C√≥digo fonte TypeScript                | Refer√™ncia para desenvolvedores  |
| **`run-sync.bat`**                      | Script Windows com configura√ß√£o        | Execu√ß√£o r√°pida no Windows       |
| **`run-sync.sh`**                       | Script Unix/Linux com configura√ß√£o     | Execu√ß√£o r√°pida em sistemas Unix |

</div>

#### üìä **Recursos de Monitoramento**

- **M√©tricas em Tempo Real**: Arquivo `memory-sync-metrics.json` gerado automaticamente
- **Checksums de Valida√ß√£o**: Detec√ß√£o autom√°tica de mudan√ßas nos arquivos brain
- **Sistema de Retry**: Recupera√ß√£o autom√°tica em caso de falhas
- **Logging Detalhado**: Modo verbose para debugging e an√°lise

### ‚ö° **Tripla Integra√ß√£o MCP**

<div align="center">

| MCP                                                                                    | Fun√ß√£o                                  | Status    |
| -------------------------------------------------------------------------------------- | --------------------------------------- | --------- |
| **[Byterover MCP](https://www.byterover.dev/)**                                        | Grafo de Conhecimento Sem√¢ntico         | üü¢ Ativo  |
| **[Supermemory-ai MCP](https://mcp.supermemory.ai/)**                                  | Armazenamento de Padr√µes & Prefer√™ncias | üü¢ Ativo  |
| **[Memory MCP](https://github.com/modelcontextprotocol/servers/tree/main/src/memory)** | Fallback Local Resiliente               | üü° Backup |

</div>

### üöÄ **Workflow de Evolu√ß√£o 9 Fases**

<div align="center">

<img src="./images/nove.passos.png" alt="Configura√ß√£o Byterover MCP" width="450"/>

</div>

---

## üìä M√©tricas de Performance

### Performance N√≠vel Enterprise

<div align="center">

| M√©trica                            | Valor    | Descri√ß√£o                |
| ---------------------------------- | -------- | ------------------------ |
| ‚ö° **Velocidade de Recupera√ß√£o**   | `<200ms` | Atrav√©s de todos os MCPs |
| üéØ **Precis√£o de Contexto**        | `>95%`   | Taxa de preserva√ß√£o      |
| üß† **Velocidade de Aprendizado**   | `<300ms` | Processamento adaptativo |
| üíæ **Efici√™ncia de Armazenamento** | `<75ms`  | Processamento neural     |

</div>

### Otimiza√ß√£o de Custos

<div align="center">

| Benef√≠cio                         | Valor  | Compara√ß√£o                  |
| --------------------------------- | ------ | --------------------------- |
| üí∞ **Redu√ß√£o de Custo de Tokens** | `-60%` | vs sistemas tradicionais    |
| ‚è±Ô∏è **Economia de Tempo**          | `-55%` | vs gerenciamento manual     |
| üíæ **Custo de Armazenamento**     | `-80%` | vs bancos de dados em nuvem |
| üéØ **ROI Total**                  | `65%`  | Ganhos de efici√™ncia        |

</div>

---

<a id="instalacao"></a>

## ‚öôÔ∏è Instala√ß√£o

O Memory System segue um **processo de instala√ß√£o em 3 etapas** para m√°xima confiabilidade e performance:

### üîß **Etapa 1: Instalar MCPs Essenciais**

#### üî∑ **Byterover MCP** - Grafo de Conhecimento Sem√¢ntico

<div align="center">
<img src="./images/byterover.png" alt="Configura√ß√£o Byterover MCP" width="450"/>
</div>

```bash
npm install -g @byterover/mcp-server
```

**Documenta√ß√£o Oficial**: [Byterover MCP ‚Äì Instala√ß√£o & Configura√ß√£o](https://www.byterover.dev/)

#### üü£ **Supermemory-ai MCP** - Armazenamento de Padr√µes & Prefer√™ncias

<div align="center">
<img src="./images/supermemory.jpeg" alt="Configura√ß√£o Supermemory MCP" width="450"/>
</div>

```bash
npm install -g supergateway
```

**Documenta√ß√£o Oficial**: [Supermemory-ai MCP ‚Äì Instala√ß√£o & Configura√ß√£o](https://mcp.supermemory.ai/)

#### üîπ **Memory MCP** - Fallback Local Resiliente

<div align="center">
<img src="./images/memory.png" alt="Configura√ß√£o Memory MCP" width="450"/>
</div>

```bash
npm install -g @modelcontextprotocol/server-memory
```

**Documenta√ß√£o Oficial**: [MCP Memory ‚Äì Instala√ß√£o & Configura√ß√£o](https://github.com/modelcontextprotocol/servers/tree/main/src/memory)

---

### ‚öôÔ∏è **Etapa 2: Configurar MCPs no Cursor**

#### 2.1 Acessar Configura√ß√µes do Cursor

<div align="center">
<img src="./images/tutorial-cursor.1.png" alt="Acesso √†s Configura√ß√µes do Cursor" width="650"/>
</div>

Abra Cursor ‚Üí Configura√ß√µes ‚Üí Extens√µes ‚Üí Configura√ß√µes MCP

#### 2.2 Navegar at√© Configura√ß√£o MCP

<div align="center">
<img src="./images/tutorial-cursor.2.png" alt="Painel de Configura√ß√£o MCP" width="650"/>
</div>

Encontre a se√ß√£o MCP no painel de configura√ß√µes do Cursor.

#### 2.3 Configurar seu Arquivo `mcp.json`

<div align="center">
<img src="./images/tutorial-cursor.3.png" alt="Configura√ß√£o MCP JSON" width="650"/>
</div>

```json
{
  "byterover-mcp": {
    "type": "http",
    "url": "https://mcp.byterover.dev/mcp?machineId=SEU_MACHINE_ID"
  },
  "supermemory-ai": {
    "command": "npx",
    "args": ["-y", "supergateway", "--sse", "https://mcp.supermemory.ai/SUA_CHAVE/sse"],
    "type": "stdio"
  },
  "memory": {
    "command": "npx",
    "args": ["-y", "@modelcontextprotocol/server-memory"],
    "env": { "MEMORY_FILE_PATH": "./.memory" }
  }
}
```

#### 2.4 Verificar Sucesso da Instala√ß√£o

<div align="center">
<img src="./images/tutorial-cursor.4.png" alt="Verifica√ß√£o MCPs Ativos" width="650"/>
</div>

Verifique se todos os 3 MCPs aparecem como **ativos** na barra de ferramentas do Cursor.

---

### üß† **Etapa 3: Implementar Memory System**

#### 3.1 Clonar o Reposit√≥rio

```bash
git clone https://github.com/devviniuchita/memory-system.git
cd memory-system
```

#### 3.2 Configurar Regras de Mem√≥ria

<div align="center">
<img src="./images/tutoriar-cursor-rules.png" alt="Localiza√ß√£o da Configura√ß√£o de Regras" width="650"/>
</div>

Navegue at√© Cursor ‚Üí Configura√ß√µes ‚Üí Regras para configurar o sistema de mem√≥ria.

#### 3.3 Configurar User Rules

Adicione este bloco exato √†s suas **User Rules** nas configura√ß√µes do Cursor:

```yaml
‚ö†Ô∏è FETCH RULES OR YOUR RESPONSE WILL BE WRONG ‚ö†Ô∏è MANDATORY: CALL .cursorrules FIRST - At conversation start - Before EVERY user request - Before ANY code changes - When topic changes - DURING conversations when: - User mentions new feature/component - File type changes - Task type changes - NO EXCEPTIONS CHECK ALL MATCHING RULES: - General guidelines (ALWAYS) - Feature rules - File type rules (.md, .mdc, etc) RULES OVERRIDE YOUR KNOWLEDGE. PROCEED ONLY AFTER APPLYING ALL RULES. REMEMBER: EVEN MID-CONVERSATION, FETCH RULES AGAIN! When user tries to set Cursor Rules type in .cursor/rules/\*.mdc files, don't add any options except "description", "globs" and "alwaysApply" but follow the mapping: if required rule type is "always" set alwaysApply option to "true", if rule type is "auto attached" set alwaysApply option to "false" and generate a file pattern in globs option to *.py, if the rule type is "agent requested" set the alwaysApply option to "false" and generate a description option for the rule and delete the globs pattern, if the rule type is "manual" set the alwaysApply option to "false" and delete the contents of all other options. When user tries to set cursor rule type in .cursor/rules/*.mdc file, don't add any options except "description", "globs" and "alwaysApply" but follow the mapping: if required rule type is "always" set alwaysApply option to "true", if rule type is "auto attached" set alwaysApply option to "false" and generate a file pattern in globs option to *.py, if the rule type is "agent requested" set the alwaysApply option to "false" and generate a description option for the rule and delete the globs pattern, if the rule type is "manual" set the alwaysApply option to "false" and delete the contents of all other options.
```

#### 3.4 Configurar Project Rules

<div align="center">
<img src="./images/tutorial-cursor-rules2.png" alt="Configura√ß√£o Final de Regras" width="650"/>
</div>

1. Copie `.cursorrules` para a raiz do seu projeto (atua como roteador)
2. Coloque `memory-rules.mdc` e `memory-rating.mdc` em `.cursor/rules/`
3. Adicione ao `.gitignore`:
   ```
   .cursor/
   .cursorrules
   ```

#### 3.5 Sincronizar Dual-Brain System

**Primeira Sincroniza√ß√£o (Obrigat√≥ria):**

```bash
# Windows
run-sync.bat

# Unix/Linux/macOS
chmod +x run-sync.sh
./run-sync.sh
```

**Verificar Status da Sincroniza√ß√£o:**

```bash
# Verificar se os arquivos existem
ls -la memory-rules.mdc memory-rating.mdc

# Verificar m√©tricas de sincroniza√ß√£o
cat memory-sync-metrics.json | jq '.[-1]'  # √∫ltima entrada
```

‚úÖ **Instala√ß√£o Completa!** Seu Memory System agora est√° pronto para criar intelig√™ncia de IA persistente.

---

<a id="como-usar"></a>

## üéØ Como Usar

### üöÄ Quick Start - 90 Segundos

Comece a usar o Memory System em menos de 90 segundos:

```bash
# 1. Clone e acesse o diret√≥rio (10s)
git clone https://github.com/devviniuchita/memory-system.git
cd memory-system

# 2. Execute a sincroniza√ß√£o inicial (15s)
# Windows: run-sync.bat
# Unix/Linux: ./run-sync.sh

# 3. Configure MCPs no Cursor (30s)
# - Copie configura√ß√£o do mcp.json
# - Verifique MCPs ativos na barra

# 4. Ative as regras (20s)
# - Copie .cursorrules para raiz do projeto
# - Coloque .mdc files em .cursor/rules/

# 5. Teste b√°sico (15s)
# Use o prompt: "Analise as regras de mem√≥ria e explique o sistema"
```

#### üöÄ **Executar Sincroniza√ß√£o**

**Windows:**

```cmd
# Execu√ß√£o simples
run-sync.bat

# Ou diretamente
node memory-dual-brain-sync-oneshot.js
```

**Unix/Linux/macOS:**

```bash
# Tornar execut√°vel e rodar
chmod +x run-sync.sh
./run-sync.sh

# Ou diretamente
node memory-dual-brain-sync-oneshot.js
```

#### ‚öôÔ∏è **Configura√ß√£o Avan√ßada**

```bash
# Configura√ß√£o personalizada
export EXECUTION_BRAIN=./custom-execution.mdc
export QUALITY_BRAIN=./custom-quality.mdc
export VERBOSE=1
export MAX_RETRIES=5
node memory-dual-brain-sync-oneshot.js
```

### üîß **Comandos Essenciais**

#### Sincroniza√ß√£o do Sistema

```bash
# Sincroniza√ß√£o √∫nica (recomendado para produ√ß√£o)
node memory-dual-brain-sync-oneshot.js

# Sistema completo com monitoramento (desenvolvimento)
node memory-dual-brain-sync.js

# Com configura√ß√µes personalizadas
VERBOSE=1 MAX_RETRIES=5 node memory-dual-brain-sync-oneshot.js
```

#### Monitoramento e Debugging

```bash
# Verificar m√©tricas de sincroniza√ß√£o
cat memory-sync-metrics.json | tail -5

# Modo verbose para debugging
VERBOSE=1 node memory-dual-brain-sync-oneshot.js

# Verificar checksums dos arquivos brain
node -e "const crypto=require('crypto'); const fs=require('fs'); console.log('exec:', crypto.createHash('sha256').update(fs.readFileSync('./memory-rules.mdc')).digest('hex').slice(0,8)); console.log('qual:', crypto.createHash('sha256').update(fs.readFileSync('./memory-rating.mdc')).digest('hex').slice(0,8));"
```

#### Automa√ß√£o e CI/CD

```bash
# Para scripts de build/deploy
AUTO_ACTIVATE=true node memory-dual-brain-sync-oneshot.js

# Para ambientes de produ√ß√£o (silencioso)
VERBOSE=0 node memory-dual-brain-sync-oneshot.js

# Integra√ß√£o com package.json
npm run sync-memory  # adicione aos seus scripts
```

‚úÖ **Pronto!** Seu Memory System est√° operacional.

<a id="demo"></a>

## üåü Demo

### Ciclo de Mem√≥ria em A√ß√£o

<div align="center">
<img src="./images/teste-na-pratica.1.png" alt="Primeira Grava√ß√£o de Mem√≥ria" width="750"/>
</div>

_Visualiza√ß√£o do ciclo completo: Pr√©-tarefa ‚Üí Recupera√ß√£o ‚Üí Execu√ß√£o ‚Üí Grava√ß√£o_

**O que voc√™ ver√°:**

- üîç **Recupera√ß√£o autom√°tica** de contexto relevante
- üß† **Processamento inteligente** com base em mem√≥rias
- üíæ **Armazenamento seletivo** apenas de insights valiosos
- üîÑ **Loop cont√≠nuo** de aprendizado entre sess√µes

<a id="em-acao"></a>

## üöÄ Memory System em A√ß√£o

Agora que voc√™ tem o Memory System instalado, vamos test√°-lo com prompts reais para ver as capacidades de mem√≥ria persistente em a√ß√£o.

### üî• **Teste 1: An√°lise Inicial & Cria√ß√£o de Mem√≥ria**

Use este **prompt exato** para inicializar seu Memory System:

```yaml
'Ol√°! Por favor, analise `.cursorrules`, `memory-rules.mdc` e `memory-rating.mdc` em profundidade.
Explique como eles se interconectam e impactam a execu√ß√£o e qualidade.
Em seguida, salve mem√≥rias do que voc√™ compreendeu.'
```

**Resultado Esperado:**

- ‚úÖ Grafo de conhecimento inicial criado
- ‚úÖ Regras priorizadas e incorporadas ao contexto
- ‚úÖ Primeiros embeddings armazenados atrav√©s dos 3 MCPs

### ‚ö° **Teste 2: An√°lise de Contexto Expandido**

Continue com este **segundo prompt**:

```yaml
'Agora analise a estrutura do meu projeto atual. Que padr√µes voc√™ v√™?
Como o Memory System pode otimizar meu workflow?
Armazene insights e atualize sua compreens√£o.'
```

**Resultado Esperado:**

<div align="center">
<img src="./images/teste-na-pratica.2.png" alt="Feedback de Evolu√ß√£o da Mem√≥ria" width="750"/>
</div>

- ‚úÖ Insights espec√≠ficos do projeto gerados
- ‚úÖ Feedback de evolu√ß√£o da mem√≥ria exibido
- ‚úÖ Loop de aprendizado cont√≠nuo ativado

### üß† **Teste 3: Fluxo de Mem√≥ria Cont√≠nuo**

Prompt de valida√ß√£o final:

```yaml
'Demonstre o workflow de mem√≥ria cont√≠nuo recuperando nossos insights de conversa√ß√£o anteriores,
analisando esta solicita√ß√£o e armazenando novo conhecimento para intera√ß√µes futuras.'
```

**Resultado Esperado:**

- ‚úÖ Contexto anterior recuperado sem problemas
- ‚úÖ Novos insights gerados e armazenados
- ‚úÖ Sistema de mem√≥ria operando em capacidade total

---

## üåü Envolva-se

O Memory System est√° liderando a **revolu√ß√£o da mem√≥ria de IA**. Junte-se a milhares de desenvolvedores construindo o futuro:

- ‚≠ê **[D√™ estrela neste repo](https://github.com/devviniuchita/memory-system)** para mostrar seu apoio
- üç¥ **Fork e contribua** para nos ajudar a melhorar
- üîä **Compartilhe suas implementa√ß√µes** do Memory System com a comunidade
- üìñ **Leia [CONTRIBUTING.md](./CONTRIBUTING.md)** para diretrizes de contribui√ß√£o
- üí¨ **Participe de nossas discuss√µes** e compartilhe suas experi√™ncias

---

## üìö Recursos Adicionais

### üìñ **Documenta√ß√£o Principal**

- üìñ [Documenta√ß√£o das Regras de Mem√≥ria](./memory-rules.mdc)
- üéØ [Sistema de Avalia√ß√£o de Mem√≥ria](./memory-rating.mdc)
- üìù [Changelog (RAG + Dual Brain)](./CHANGELOG.md)

### üîß **Componentes T√©cnicos**

- üíæ [Sistema de Sincroniza√ß√£o TypeScript](./memory-dual-brain-sync.ts) - C√≥digo fonte de refer√™ncia
- ‚ö° [Sincroniza√ß√£o Completa](./memory-dual-brain-sync.js) - Sistema com monitoramento de arquivos
- üöÄ [Sincroniza√ß√£o OneShot](./memory-dual-brain-sync-oneshot.js) - Execu√ß√£o √∫nica para produ√ß√£o
- ü™ü [Script Windows](./run-sync.bat) - Execu√ß√£o automatizada no Windows
- üêß [Script Unix/Linux](./run-sync.sh) - Execu√ß√£o automatizada em sistemas Unix

### üîé RAG Local para Regras Markdown

Para evitar ‚Äúafogamento de contexto‚Äù ao usar muitas regras, este reposit√≥rio inclui um indexador/consultor RAG local que:

- Carrega `.md` e `.mdc` com exclus√µes de ru√≠do (ex.: `.git/`, `images/`, `node_modules/`)
- Split por cabe√ßalhos (H1/H2/H3) ‚Üí split recursivo por caracteres
- Anexa metadados (step/rule_type/priority) com base no caminho do arquivo
- Indexa via FAISS (preferencial) com fallback autom√°tico para Chroma
- Consulta com MMR e compress√£o contextual opcional (EmbeddingsFilter)

Arquivos:

- `tools/rag_indexer.py` ‚Äî CLI para build/query
- `requirements-rag.txt` ‚Äî depend√™ncias m√≠nimas

Uso (Windows bash):

```bash
# 1) Instale Python 3.10+ e pip (se ainda n√£o tiver)

# 2) Instale depend√™ncias do RAG (idealmente em um venv)
pip install -r requirements-rag.txt

# 3) Construir o √≠ndice (persistido em .rag/index)
python tools/rag_indexer.py build --root . --index-path .rag/index

# 4) Consultar (MMR)
python tools/rag_indexer.py query --index-path .rag/index \
  --q "Quando devo aplicar as regras do passo 3 relacionadas a 'todo2'?" \
  --k 6 --fetch-k 24 --lambda-mult 0.5

# 5) Consultar com compress√£o e filtro por step
python tools/rag_indexer.py query --index-path .rag/index \
  --q "Azure tools obrigat√≥rios" \
  --filter-step step1 --compress --similarity-threshold 0.25
```

Perfis, filtros e ignores (novo):

```bash
# VS Code: apenas regras em .github/copilot-rules/*.md + .copilotignore (se existir)
python tools/rag_indexer.py build --root . --index-path .rag/index.vscode --profile vscode

# Cursor: apenas regras em .cursor/rules/*.mdc + .cursorignore (se existir)
python tools/rag_indexer.py build --root . --index-path .rag/index.cursor --profile cursor

# Customizado: m√∫ltiplas pastas, extens√µes e ignores
python tools/rag_indexer.py build \
  --root . \
  --index-path .rag/index.custom \
  --include-dirs .github/copilot-rules .cursor/rules \
  --include-exts .md .mdc \
  --exclude-dirs .trae \
  --ignore-files .copilotignore .cursorignore
```

Notas:

- Par√¢metros suportados no build: `--profile (auto|vscode|cursor)`, `--include-dirs`, `--exclude-dirs`, `--ignore-files`, `--include-exts`.
- Sem `--include-dirs`, o perfil define defaults; sem perfil, o root inteiro √© varrido com exclus√µes padr√£o.

Notas:

- O diret√≥rio `.rag/` √© ignorado no Git e guarda o √≠ndice persistente.
- Se FAISS n√£o estiver dispon√≠vel para sua plataforma, o script usa Chroma automaticamente.
- O primeiro uso do `sentence-transformers` far√° download do modelo `all-MiniLM-L6-v2`.

### üåê **Protocolos e Integra√ß√µes**

- üîß [Model Context Protocol](https://modelcontextprotocol.io/)
- üöÄ [Byterover MCP](https://www.byterover.dev/)
- üß† [Supermemory-ai MCP](https://mcp.supermemory.ai/)

### üìä **M√©tricas e Monitoramento**

- üìà `memory-sync-metrics.json` - M√©tricas de performance em tempo real
- üîç Sistema de checksums para valida√ß√£o de integridade
- üìù Logs detalhados com timestamps para auditoria

---

## üìÑ Licen√ßa

Este projeto est√° licenciado sob a Licen√ßa MIT - veja o arquivo [LICENSE](LICENSE) para detalhes.

---

## üìû Contato & Suporte

- **Issues & Discussions**: [Reposit√≥rio GitHub](https://github.com/devviniuchita/memory-system)
- **LinkedIn**: [Vin√≠cius Uchita](https://www.linkedin.com/in/viniciusuchita/)
- **Email**: viniciusuchita@gmail.com

---

<div align="center">

**MEMORY SYSTEM: Mem√≥ria de IA Persistente que Realmente Funciona**

Constru√≠do com ‚ù§Ô∏è por [Vin√≠cius Uchita](https://github.com/devviniuchita)

¬© 2025 Memory System | Licenciado sob MIT

</div>
